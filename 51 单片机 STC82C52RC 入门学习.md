---
title: 51单片机STC82C52RC入门学习
date: 2023-10-14 22:30:15
tag:
  - 51
  - STC89C52RC
  - AT24C02
  - I2C
  - DS1302
categories: 
  - 笔记
  - 学习
cover: ../images/2023/51单片机STC89C52RC入门学习/封面.png
---

# Keil & STC-ISP

## Keil uVision5 C51

`Keil uVision` 有很多版本，`STC89C51RC`单片机用的是C51版本

> **Project** → **new vision project** → 选存放位置 → 选择 **AT89C52**单片机 →  创建完毕 → 在**Options for Target/Output** 下点选上**Create HEX_File**，这样就可以编译后生成可烧录文件了

> **Target/Source Group** 下右键，**ADD NEW**为新建一个文件，**ADD Existing**为添加文件目录下的其他文件

## STC-ISP

> 单片机型号选择 **STC89C52RC/LE52RC**，其他系统自动    

----





# STC89C52单片机核心



![STC89C52单片机核心](../images/2023/51单片机STC89C52RC入门学习/STC89C52单片机核心.png)





# LED

**单片机 I/O 两种状态，1为高电平即5V，0为低电平0V**



### 点亮LED

使用十六进制数可直接控制8个LED灯的亮灭，也可使用2进制数控制单独一个等的状态：

```c
P2 = 0x01; // 0000 0001
```



### 跑马灯

按顺序逐一点亮LED，并通过延时程序可被观察到

```c
unsigned char LEDNUM = 0;
while(1){ // P2_0 -> P2_7
	LEDNUM++;
    if (LEDNUM >= 8){
        LEDNUM = 0;
    }
    /*
		这里让LED只亮一个完成跑马灯操作
		用LEDNUM来记录亮灯位置，通过位运算来实现跑马特效
		因为是定向移动，所以只需要判断LEDNUM是否达到临界值即可
		使用位操作来控制亮灯位置，又因为高低电平的缘故，需要对高电平操作	0000 1000
		最后对高电平操作的结果进行取反操作							 1111 0111
	*/
    P2 = ~(0x01 << LEDNUM);
}
while(1){ // P2_7 -> P2_0
	if (LEDNUM == 0){
		LEDNUM = 7;
	}else{
		LEDNUM--;
	}
    P2 = ~(0x01 << LEDNUM);
}
```



### 延时 Delay

不同频率芯片的延时各不相同

![Delay延时计算器](../images/2023/51单片机STC89C52RC入门学习/Delay延时计算器.png)

```c
void Delay1ms()		//@12.000MHz
{
	unsigned char i, j;

	i = 2;
	j = 239;
	do
	{
		while (--j);
	} while (--i);
}
```



# 按键

按键使用方法和LED类似

### 按键抖动

按键拨片在按下和抬起瞬间难免发生抖动造成数据波动

可通过延时函数来消除这5~10ms的波动影响

```c
while(1){
    if (P3_1 == 0){
        Delay_ms(20);
        while(P3_1 == 0);
        Delay_ms(20);
        ...
    }
}
```

### 二进制计数

通过点按一个按键来实现二进制计数

```c
unsigned char NUM = 0;
while(1){
    if (P3_1 == 0){
        ... //消除按键抖动        
      	NUM++;
      	P2 = ~NUM;
    }
}
```

### 按键控制LED移位

通过按键实现LED的左右移动

其实就是跑马灯加上一个按键控制

```c
unsigned char LEDNUM = 0;
P2 = ~0x01;
while(1){		
    if (P3_0 == 0){
        Delay(20);
        while(P3_0 == 0);
        Delay(20);

        LEDNUM++;
        if (LEDNUM >= 8){
            LEDNUM = 0;
        }
        P2 = ~(0x01<<LEDNUM);
    }else if (P3_1 == 0){
        Delay(20);
        while(P3_1 == 0);
        Delay(20);			

        if (LEDNUM == 0){
            LEDNUM = 7;
        }else{
            LEDNUM--;
        }
        P2 = ~(0x01<<LEDNUM);
    }
}
```

# 数码管

数码管由74HC138译码器和动态数码管模块组成

数码管需要进行消影，在快速位选段选中上一个数据会窜到下一位数据里，形成重影

只需要加入一个极短的延时就可以解决





# 矩阵键盘





# 定时器



##### 

# 串口通信

#### 波特率计算器

在STC-IPS软件中有波特率计算功能，注意参数配置就好了，误差比较大的时候可以勾选 波特率倍速SMOD 来降低误差

|   系统频率   |     波特率     |   波特率倍速SMOD   |      误差      |
| :----------: | :------------: | :----------------: | :------------: |
|  11.0592MHz  |      4800      |     看情况勾选     |       ~        |
| **UART选择** | **UART数据位** |  **波特率发生器**  | **定时器时钟** |
|    串口1     |    8位数据     | 定时器1（8位重载） | 12T（FOSC/12） |

发送和接受设备需要保持相同的波特率才能正确的传输数据，还有应尽可能**不要将传输间隔小于误差值**，可通过短暂的延时函数解决！



# LED点阵屏



# 时钟 DS1302

![DS1302工作原理](../images/2023/51单片机STC89C52RC入门学习/DS1302工作原理.png)







# I2C总线





# AT24C02

> AT24C02掉电不丢失存储器

![AT24C02掉电不丢失存储器](../images/2023/51单片机STC89C52RC入门学习/AT24C02.png)





----

